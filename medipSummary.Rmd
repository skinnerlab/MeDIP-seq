---
output: pdf_document
---

<!-- Created 7/9/2015 by Daniel Beck-->
<!-- Last modified 5/24/2016 -->
<!-- This report generates a subset of the MeDIP-seq analysis summary. It is usually called by -->
<!-- the generateReports.R script and requires the presence of a reportValues.Rdata file (this -->
<!-- file is generated by generateReports.R). -->

```{r, echo = FALSE, message = FALSE, warning = FALSE}

# Load relevant libraries, custom functions, and the configuration script. Note, the
# order is important, as dataNames.R holds information about the bsgenomePackageName.
source("dataNames.R")
source("customFunctions.R")
library(pander)
library(MEDIPS)
library(bsgenomePackageName, character.only = T, lib.loc = genomeDirectory)

#############################
## Load results parameters ##
#############################
## This step gets the report parameters from reportValues.Rdata and loads the appropriate
## result files for the MeDIP-seq analysis of interest.

# This file holds information on specific report variables. It is generated by generateReports.R
load("reportValues.Rdata")

# Select the desired comparison
an <- which(comparisonNames == analysisName)

# List position for these p-values
pvc <- which(pValues == reportPvalue)
MTCpvc <- which(MTCpValues == MTCreportPvalue)

# Load MeDIP-seq analysis results
load(paste(resultsDirectory, comparisonNames[an], "/methLists.RData", sep = ""))
load(paste(resultsDirectory, comparisonNames[an], "/methResults.RData", sep = ""))
load(paste(resultsDirectory, "qcLists.RData", sep=""))
```

# MeDIP analysis summary for the `r projectName` project (brief version)
Report generated `r format(Sys.Date(), format = "%B %d %Y")`
Comparison: `r comparisonNames[an]`

## Sample comparison
The samples `r paste(seqFiles$sampleName[comparison[[an]]$mset1], collapse = ", ")` were compared with the samples `r paste(seqFiles$sampleName[comparison[[an]]$mset2], collapse = ", ")`.

## Raw data cleaning and mapping
`r ifelse(cleanReads, "The raw data was cleaned and filtered to remove adapters and low-quality bases using Trimmomatic.", ifelse(useCleanReads, "The raw data was cleaned and filtered. The exact methods are not specified.", "No cleaning or filtering of the raw data is specified."))`

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
sn <- c(seqFiles$sampleName[comparison[[an]]$mset1], seqFiles$sampleName[comparison[[an]]$mset2])

if (useCleanReads) {
  readCounts <- data.frame("sampleName" = sn, 
                           "rawReadPairs" = NA,
                           "cleanReadPairs" = NA,
                           "cleanReadSingles" = NA,
                           "pctCleanPairs" = NA,
                           "pctCleanTotal" = NA)
  for (i in 1:length(sn)) {
    subInd <- match(sn[i], seqFiles$sampleName)
    tempRawFileName <- seqFiles$p1FileName[subInd]
    tempCpFileName <- cleanFileNames[subInd, 1]
    tempS1FileName <- cleanFileNames[subInd, 3]
    tempS2FileName <- cleanFileNames[subInd, 4]
  
    cRaw <- paste("zcat ", dataDirectory, tempRawFileName, ' | grep "^@" | wc -l', sep="")
    cPair <- paste("zcat ", dataDirectory, tempCpFileName, ' | grep "^@" | wc -l', sep="")
    cS1 <- paste("zcat ", dataDirectory, tempS1FileName, ' | grep "^@" | wc -l', sep="")
    cS2 <- paste("zcat ", dataDirectory, tempS2FileName, ' | grep "^@" | wc -l', sep="")
    
    numRaw <- as.numeric(system(cRaw, intern=T))
    numPair <- as.numeric(system(cPair, intern=T))
    numS1 <- as.numeric(system(cS1, intern=T))
    numS2 <- as.numeric(system(cS2, intern=T))
  
    totalS <- numS1 + numS2
    readCounts[i, 2:6] <- c(numRaw, numPair, totalS, numPair / numRaw, (numPair + totalS) / numRaw)
  }
  row.names(readCounts) <- readCounts[,1]
  readCounts <- readCounts[, -1]
  #pandoc.table(readCounts, split.tables = 110, style = "rmarkdown", 
  #             caption = "This table shows the number and percent of reads before and 
  #                       after read filtering and trimming.")
}

```


```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
fnTable <- as.data.frame(seqFiles[match(sn, seqFiles$sampleName), ])
row.names(fnTable) <- fnTable$sampleName
fnTable <- fnTable[, -1]
colnames(fnTable) <- c("first end filename", "second end filename", "sample type")
#pandoc.table(fnTable, split.tables = 110, style = "rmarkdown", 
#             caption = "This table shows the association between the samples 
#                       and the raw data files.")
```

The raw data consists of 50bp paired end reads. The reads were mapped to the reference genome using Bowtie2. The *`r species`* reference genome was provided by `r provider` and was downloaded from `r genomeSourceFiles`. The mapped reads were converted to the sorted BAM file format using Samtools.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
if (mapReads){
  pandoc.table(mapExtract(cleaned = useCleanReads), split.tables = Inf, style = "rmarkdown", 
               caption = 'This table shows the number of reads present for each sample 
                         and the overall alignment rate calculated by bowtie2.')
}

```



************

## Differential coverage analysis
The differential coverage analysis was performed using the MEDIPS R package. The analysis used a windows size of `r ws`bp. DMRs were defined using a `r diff.method` p-value threshold of `r reportPvalue`. The DMR edges were extended to include neighboring windows with a p-value less than `r dmrBoundPvalue`. Genomic windows are considered neighboring if they are within `r adjDist`bp of the DMR boundary. In other words, DMR edges are extended until there is no genomic window within `r adjDist`bp with a p-value less than `r dmrBoundPvalue`. 

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

pandoc.table(as.data.frame(dmrNumberTable), split.tables = 110, style = "rmarkdown", 
             caption = "This table shows the number of DMRs found using different p-value cutoff 
                     thresholds. The allWindow column shows all DMRs. The twoWindow column 
                     shows the number of DMRs containing at least two significant windows.")

#pandoc.table(as.data.frame(MTCdmrNumberTable), split.tables = 110, style = "rmarkdown", 
#             caption = "This table shows the number of DMRs found using different multiple 
#                       testing corrected p-value cutoff thresholds. The allWindow column shows 
#                       all DMRs. The twoWindow column shows the number of DMRs containing at least 
#                       two significant windows.")

```

************

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
nWin <- table(methList[[pvc]]$numSigWin)
nWinTable <- as.data.frame(matrix(ncol = length(nWin), nrow = 2, c(names(nWin), nWin), byrow = T))
row.names(nWinTable) <- c("Number of significant windows", "Number of DMR")
colnames(nWinTable) <- rep(" ", ncol(nWinTable))
pandoc.table(nWinTable, split.tables = 110, style = "rmarkdown", 
             caption = paste("This table shows the number of DMR with each specific number of 
                             significant windows at a p-value threshold of ", 
                             reportPvalue, sep = ""))
             
```


### Chromosome plot

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}
# Find clusters
dmrList <- methList[[pvc]]

clusterObject <- slidingWindowCluster(formatForCluster(dmrList), 
                                      windowLength = 2000000, incrementLength = 50000)
colnames(clusterObject) <- c("chr", "start", "stop", "minP")
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths, 
                ymar = 5, clusters = clusterObject)

```

**Figure 1.** This figure shows the DMR locations on the individual chromosomes or contigs. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}
# find clusters
dmrList <- methList2p[[pvc]]

clusterObject <- slidingWindowCluster(formatForCluster(dmrList), 
                                      windowLength = 2000000, incrementLength = 50000)
colnames(clusterObject) <- c("chr", "start", "stop", "minP")
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths, 
                ymar = 5, clusters = clusterObject)

```

**Figure 2.** This figure shows the DMR locations on the individual chromosomes or contigs. Only DMRs containing at least two significant windows at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.


******

### CpG density histogram

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
par(mar = c(5, 5, 4, 2) + 0.1)
plotCpGdensity(methList[[pvc]], main = "", xlab = "Number of CpG sites per 100bp", 
               ylab = "Number of differential DNA \n methylation regions")
```

**Figure 3.** This figure is a histogram of the number of DMRs at different CpG densities. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
par(mar=c(5, 5, 4, 2) + 0.1)
plotCpGdensity(methList2p[[pvc]], main = "", xlab = "Number of CpG sites per 100bp",
               ylab = "Number of differential DNA \n methylation regions")
```

**Figure 4.** This figure is a histogram of the number of DMRs at different CpG densities. Only DMRs containing at least two significant windows at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.


### DMR characteristics

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
plotDMRlength(methList[[pvc]])
```

**Figure 5.** This figure is a histogram of the DMR lengths. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
plotDMRlength(methList2p[[pvc]])
```

**Figure 6.** This figure is a histogram of the DMR lengths. Two window DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.
