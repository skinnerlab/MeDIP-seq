---
output: pdf_document
dev: cairo_pdf
---

<!-- Created 7/9/2015 by Daniel Beck-->
<!-- Last modified 4/2/2018 -->
<!-- This report generates the main MeDIP-seq analysis summary. It is usually called by the -->
<!-- generateReports.R script and requires the presence of a reportValues.Rdata file (this -->
<!-- file is generated by generateReports.R). -->

```{r, echo = FALSE, message = FALSE, warning = FALSE}

# Load relevant libraries, custom functions, and the configuration script. Note, the
# order is important, as dataNames.R holds information about the bsgenomePackageName.
source("dataNames.R")
source("customFunctions.R")
library(pander)
library(MEDIPS)
library(bsgenomePackageName, character.only = T, lib.loc = genomeDirectory)
library(Heatplus)

#############################
## Load results parameters ##
#############################
## This step gets the report parameters from reportValues.Rdata and loads the appropriate
## result files for the MeDIP-seq analysis of interest.

# This file holds information on specific report variables. It is generated by generateReports.R
load("reportValues.Rdata")

# Select the desired comparison
an <- which(comparisonNames == analysisName)

# List position for these p-values
pvc <- which(pValues == reportPvalue)

# Load MeDIP-seq analysis results
load(paste(resultsDirectory, comparisonNames[an], "/methLists.RData", sep = ""))
load(paste(resultsDirectory, comparisonNames[an], "/methResults.RData", sep = ""))
load(paste(resultsDirectory, "qcLists.RData", sep=""))

sn <- c(seqFiles$sampleName[comparison[[an]]$mset1], seqFiles$sampleName[comparison[[an]]$mset2])


```

# MeDIP analysis summary for the `r projectName` project
Report generated `r format(Sys.Date(), format = "%B %d %Y")`

Comparison: `r comparisonNames[an]`

Description: `r comparisonDescription[[an]]`

`r if (!is.na(topN)) paste("Only the top ", topN, " DMR are used to generate figures.", sep="")`


## Sample comparison
The samples `r paste(seqFiles$sampleName[comparison[[an]]$mset1], collapse = ", ")` were compared with the samples `r paste(seqFiles$sampleName[comparison[[an]]$mset2], collapse = ", ")`. The samples were analyzed in `r ifelse(comparison[[an]]$pairs[1], 'pairs', 'groups')`.

## Raw data cleaning and mapping
`r ifelse(cleanReads, "The raw data was cleaned and filtered to remove adapters and low-quality bases using Trimmomatic. The following table shows the differences in read numbers in the raw and cleaned files.", ifelse(useCleanReads, "The raw data was cleaned and filtered. The exact methods are not specified. The following table shows the differences in read numbers in the raw and cleaned files.", "No cleaning or filtering of the raw data is specified."))`

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

if (useCleanReads) {
  readCounts <- data.frame("sampleName" = sn, 
                           "rawReadPairs" = NA,
                           "cleanReadPairs" = NA,
                           "cleanReadSingles" = NA,
                           "pctCleanPairs" = NA,
                           "pctCleanTotal" = NA)
  for (i in 1:length(sn)) {
    subInd <- match(sn[i], seqFiles$sampleName)
    tempRawFileName <- seqFiles$p1FileName[subInd]
    tempCpFileName <- cleanFileNames[subInd, 1]
    tempS1FileName <- cleanFileNames[subInd, 3]
    tempS2FileName <- cleanFileNames[subInd, 4]
  
    cRaw <- paste("zcat ", dataDirectory, tempRawFileName, ' | wc -l', sep="")
    cPair <- paste("zcat ", dataDirectory, tempCpFileName, ' | wc -l', sep="")
    cS1 <- paste("zcat ", dataDirectory, tempS1FileName, ' | wc -l', sep="")
    cS2 <- paste("zcat ", dataDirectory, tempS2FileName, ' | wc -l', sep="")
    
    numRaw <- as.numeric(system(cRaw, intern=T))/4
    numPair <- as.numeric(system(cPair, intern=T))/4
    numS1 <- as.numeric(system(cS1, intern=T))/4
    numS2 <- as.numeric(system(cS2, intern=T))/4
  
    totalS <- numS1 + numS2
    readCounts[i, 2:6] <- c(numRaw, numPair, totalS, numPair / numRaw, (numPair + totalS) / numRaw)
  }
  # Double underscore is a special character, remove them.
  readCounts$sampleName <- gsub(readCounts$sampleName, pattern="__", replacement="_")
  row.names(readCounts) <- readCounts[,1]
  readCounts <- readCounts[, -1]
  pandoc.table(readCounts, split.tables = 100, style = "simple", 
               caption = "This table shows the number and percent of reads before and 
                         after read filtering and trimming.")
}

```


The following table shows the association between the samples and the original data files.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
fnTable <- as.data.frame(seqFiles[match(sn, seqFiles$sampleName), ])
fnTable$sampleName <- gsub(fnTable$sampleName, pattern="__", replacement="_")
row.names(fnTable) <- fnTable$sampleName
fnTable <- fnTable[, -1]
colnames(fnTable) <- c("first end filename", "second end filename", "sample type")
pandoc.table(fnTable, split.tables = 100, style = "simple", 
             caption = "This table shows the association between the samples 
                       and the raw data files.")
```

A quality report for each raw data file was generated using FastQC and is available in the folder `r dataDirectory`. The raw data consists of 50bp paired end reads. The reads were mapped to the reference genome using Bowtie2.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
if (mapReads){
  tmp <- mapExtract(cleaned = useCleanReads, sn=sn)
  colnames(tmp) <- gsub(colnames(tmp), pattern="__", replacement="_")
  pandoc.table(tmp, split.tables = 100, style = "simple", 
               caption = 'This table shows the number of reads present for each sample 
                         and the overall alignment rate calculated by bowtie2.')
}

```

The *`r species`* reference genome was provided by `r provider` and was downloaded from `r genomeSourceFiles`. The mapped reads were converted to the sorted BAM file format using Samtools.


## Differential coverage analysis
The differential coverage analysis was performed using the MEDIPS R package. The analysis used a windows size of `r ws`bp. The `r diff.method` method was used to calculate p-values. The `r p.adj` multiple testing adjustment was also calculated. Annotation information was downloaded from `r ifelse(annotationType == "biomart", 'the Ensembl database using the biomaRt R package', annotationSource)`.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
ptable <- data.frame("unique"=uniq, "extend"=extend, "shift"=shift, "window.size"=ws, "p.adj"=p.adj, "diff.method"=diff.method, "min.row.sum"=mrs)
pandoc.table(ptable, split.tables = 100, style = "simple", 
             caption = 'This table shows various parameters used for the MEDIPS analysis')
```

### DMR definition
DMRs were defined using a `r diff.method` p-value threshold of `r reportPvalue`. The DMR edges were extended to include neighboring windows with a p-value less than `r dmrBoundPvalue`. Genomic windows are considered neighboring if they are within `r adjDist`bp of the DMR boundary. In other words, DMR edges are extended until there is no genomic window within `r adjDist`bp with a p-value less than `r dmrBoundPvalue`.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
colnames(dmrNumberTable) <- c("p-value", "all", "multipleWindow")
colnames(MTCdmrNumberTable) <- c("p-value", "all", "multipleWindow")


pandoc.table(as.data.frame(dmrNumberTable), split.tables = 100, style = "simple", 
             caption = "This table shows the number of DMRs found using different p-value cutoff 
                     thresholds. The all column shows all DMRs. The multipleWindow column 
                     shows the number of DMRs containing at least two significant windows.")


pandoc.table(as.data.frame(MTCdmrNumberTable), split.tables = 100, style = "simple", 
             caption = "This table shows the number of DMRs found using different multiple 
                       testing corrected p-value cutoff thresholds. The all column shows 
                       all DMRs. The multipleWindow column shows the number of DMRs containing at least 
                       two significant windows.")


```

************

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
nWin <- table(methList[[pvc]]$numSigWin)
nWinTable <- as.data.frame(matrix(ncol = length(nWin), nrow = 2, c(names(nWin), nWin), byrow = T))
row.names(nWinTable) <- c("Number of significant windows", "Number of DMR")
colnames(nWinTable) <- rep(" ", ncol(nWinTable))
pandoc.table(nWinTable, split.tables = 100, style = "simple", 
             caption = paste("This table shows the number of DMR with each specific number of 
                             significant windows at a p-value threshold of ", 
                             reportPvalue, sep = ""))
             
```



\newpage

## Chromosome plot

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8, dev='cairo_pdf'}

# Include option to only look at top N DMR (by minimum p-value) This applies to all folowing figures.
if (!is.na(topN)) {
  methList[[pvc]] <- methList[[pvc]][order(methList[[pvc]]$minP)[1:(topN+1)],]
  methList[[pvc]] <- methList[[pvc]][order(as.numeric(row.names(methList[[pvc]]))),]
  reportPvalue <- max(methList[[pvc]]$minP)
  methList[[pvc]] <- methList[[pvc]][which(methList[[pvc]]$minP < reportPvalue),]
}


# Find clusters
dmrList <- methList[[pvc]]

if (nrow(dmrList) < 5000){
if (nrow(dmrList) > 1){
  clusterObject <- slidingWindowCluster(formatForCluster(dmrList),
                                        windowLength = 2000000, incrementLength = 50000)
  colnames(clusterObject) <- c("chr", "start", "stop", "minP")
} else {
  clusterObject <- NULL
}
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths,
                ymar = 5, clusters = clusterObject, cex.lab=1.5)

}
```

**Figure 1.** This figure shows the DMR locations on the individual chromosomes or contigs. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.


\newpage

## DMR CpG density and length figures

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, fig.width=6, dev='cairo_pdf'}
if (is.null(methList[[pvc]]$cpgDensity)) {
  methList[[pvc]] <- calcCpGdensity(modifyStop(methList[[pvc]], refGenom=eval(parse(text = referenceName)), maxDMR=1000000), maxDMR=100000)
}
par(mar = c(5, 5, 2, 1) + 0.1, lwd=2)
if (is.na(cpgMax)){
  plotCpGdensity(methList[[pvc]], xlab = "Number of CpG sites per 100bp", cex.lab=2, cex.axis=1.6, lwd=2, ylab = "Number of DMR")
} else {
  plotCpGdensity(methList[[pvc]], xlab = "Number of CpG sites per 100bp", cex.lab=2, cex.axis=1.6, lwd=2, 
                 ylab = "Number of DMR", ylim=c(0, cpgMax))
}
```

**Figure 2.** This figure is a histogram of the number of DMRs at different CpG densities. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

\newpage


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, fig.width=6, dev='cairo_pdf'}
par(mar = c(5, 5, 2, 1) + 0.1, lwd=2)
if (is.na(lenMax)){
  plotDMRlength(methList[[pvc]], axis.fixed=T, cex.lab=2, cex.axis=1.6, lwd=2, ylab = "Number of DMR")
} else {
  plotDMRlength(methList[[pvc]], axis.fixed=T, cex.lab=2, cex.axis=1.6, lwd=2, 
                ylab = "Number of DMR", ylim=c(0, lenMax))
}
```

**Figure 3.** This figure is a histogram of the DMR lengths. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

\newpage


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, dev='cairo_pdf'}
if(!is.null(methList[[pvc]]$cpgNum)){
  par(mar = c(5, 5, 2, 1) + 0.1, lwd=2)
  plot(methList[[pvc]]$cpgNum, methList[[pvc]]$length, xlab = "Number of CpGs", 
       ylab = "DMR length (bp)", cex.axis=1.6, cex.lab=2, cex=2)
}
```

**Figure 4.** This figure shows the DMR length vs number of CpGs. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

\newpage

## Overall p-value distribution
The overall p-value distribution shows a summary of the p-values for each genomic window. Odd patterns in the histogram below may indicate problems with the data or the analysis.

```{r, echo = FALSE, message = FALSE, warning = FALSE, dev='cairo_pdf'}
layout(matrix(c(1, 2), nrow = 2), heights = c(1, 1.5))
par(mar = c(2.1, 4.1, 1.1, 2.1))
a <- hist(methResults$edgeR.p.value, breaks = 100, main = "", xlab = "")
par(mar = c(5.1, 4.1, 1.1, 2.1))
ylim <- sort(a$counts, decreasing = TRUE)[2]
if (is.na(ylim)) ylim <- 1
hist(methResults$edgeR.p.value, breaks = 100, 
     ylim = c(0, ylim), xlab = "edgeR p-value", main = "")
```

**Figure 5.** This figure shows the histogram of the edgeR p-values for all genomic windows. The top plot shows the entire histogram while the bottom plot has a truncated y-axis to better show low-frequency p-values.

\newpage


```{r, echo = FALSE, message = FALSE, warning = FALSE, dev='cairo_pdf'}
layout(matrix(c(1, 2), nrow = 2), heights = c(1, 1.5))
par(mar = c(2.1, 4.1, 1.1, 2.1))
a <- hist(methResults$edgeR.adj.p.value, breaks = 100, main = "", xlab = "")
par(mar = c(5.1, 4.1, 1.1, 2.1))
ylim <- sort(a$counts, decreasing = T)[2]
if (is.na(ylim)) ylim <- 1
hist(methResults$edgeR.adj.p.value, breaks = 100, ylim = c(0, ylim), 
     xlab = paste(p.adj, " adjusted p-value", sep = ""), main = "")
```

**Figure 6.** This figure shows the histogram of the `r paste(p.adj, " adjusted p-values", sep="")` for all genomic windows. The top plot shows the entire histogram while the bottom plot has a truncated y-axis to better show low-frequency p-values.

\newpage


## Other figures for QC

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 9, dev='cairo_pdf'}

a <- as.data.frame(corMatrix)
colnames(a) <- seqFiles$sampleName[match(colnames(corMatrix), sbamFileName)]
row.names(a) <- seqFiles$sampleName[match(row.names(corMatrix), sbamFileName)]
a <- a[which(match(row.names(a), sn, nomatch=0)>0), which(match(colnames(a), sn, nomatch=0)>0)]

row.names(a) <- gsub(row.names(a), pattern="__", replacement="_")
colnames(a) <- gsub(colnames(a), pattern="__", replacement="_")
for(i in 2:nrow(a)){
  for(j in 1:(i-1)){
    a[i, j] <- a [j, i]
  }
}
heatmap_2(as.matrix(a), Rowv=NA, Colv=NA, scale="none", legend=2, legfrac=6)


```

**Figure 7.** This heatmap shows the pairwise Pearson correlation coefficient between sample coverage profiles.

\newpage



```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 9, dev='cairo_pdf'}

subCoverList <- coverList[which(match(seqFiles$sampleName, sn, nomatch=0)>0)]
tableCoverList <- lapply(subCoverList, function(i) table(i$cov.res))

a <- data.frame(
           "0 read CpGs"=sapply(tableCoverList, function(i) i[which(names(i)=="0")]/sum(i)*100),
           "1-5 read CpGs"=sapply(tableCoverList, function(i) sum(i[which((as.numeric(names(i))>0)&(as.numeric(names(i))<6))])/sum(i)*100),
           "6-10 read CpGs"=sapply(tableCoverList, function(i) sum(i[which((as.numeric(names(i))>5)&(as.numeric(names(i))<11))])/sum(i)*100),
           ">10 read CpGs"=sapply(tableCoverList, function(i) sum(i[which(as.numeric(names(i))>10)])/sum(i)*100))
row.names(a) <- sn
colnames(a) <- c("0", "1-5", "6-10", ">10")
heatmap_2(as.matrix(a), Rowv=NA, Colv=NA, scale="col", legend=2, legfrac=6)

```

**Figure 8.** This heatmap summarizes the percent of genome wide CpGs at different coverage levels. The data is scaled by column to highlight differences between samples at each coverage level. The coverage is not adjusted for library size.


```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}


hrt <- data.frame(
             "c0"=sapply(tableCoverList, function(i) paste(format(i[which(names(i)=="0")]/sum(i)*100, digits=3), "%", sep="")),
             "c1"=sapply(tableCoverList, function(i) paste(format(sum(i[which((as.numeric(names(i))>0)&(as.numeric(names(i))<6))])/sum(i)*100, digits=3), "%", sep="")),
             "c6"=sapply(tableCoverList, function(i) paste(format(sum(i[which((as.numeric(names(i))>5)&(as.numeric(names(i))<11))])/sum(i)*100, digits=3), "%", sep="")),
             "cg10"=sapply(tableCoverList, function(i) paste(format(sum(i[which(as.numeric(names(i))>10)])/sum(i)*100, digits=3), "%", sep="")))
row.names(hrt) <- sn
colnames(hrt) <- c("0 read CpGs", "1-5 read CpGs", "6-10 read CpGs", ">10 read CpGs")
pandoc.table(hrt, split.tables=100, style="simple", caption="This table shows the percent of genome wide CpGs at different coverage levels (read depths). The coverage is not adjusted for library size.")
```

\newpage


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, dev='cairo_pdf'}

par(mfcol=c(1,1))
mset1.counts <- methResults$MSets1.rpkm.mean
mset2.counts <- methResults$MSets2.rpkm.mean
prop.counts <- mset1.counts / (mset1.counts + mset2.counts)

pvt.filter <- which(methResults$edgeR.p.value < reportPvalue)
filt.m1.c <- mset1.counts[pvt.filter]
filt.m2.c <- mset2.counts[pvt.filter]
filt.prop.c <- prop.counts[pvt.filter]

ms1n <- paste(unique(seqFiles[comparison[[an]]$mset1,"ctFlag"]), collapse="")
ms2n <- paste(unique(seqFiles[comparison[[an]]$mset2,"ctFlag"]), collapse="")

par(mar=c(5,4,4,5)+.1)
plot(1:length(filt.prop.c), filt.m1.c[order(filt.prop.c)], 
     ylim=c(0, max(c(filt.m1.c, filt.m2.c))), type="l", 
     col="red", xlab="Genomic window", ylab="Mean RPKM")
points(1:length(filt.prop.c), filt.m2.c[order(filt.prop.c)], type="l", col="blue")
legend("topleft", fill=c("red", "blue", "black"), c(ms1n, ms2n, paste("% ", ms1n, sep="")))
par(new=TRUE)
plot(1:length(filt.prop.c), filt.prop.c[order(filt.prop.c)], type="l", 
     col="black", xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, col="black")
mtext(paste("% RPKM read depth in ", ms1n, sep=""), side=4, line=3, col="black")
```

**Figure 9a.** This figure shows mean read number (RPKM) of genomic windows with an edgeR p-value < `r format(reportPvalue, scientific = T)`. Genomic windows are ordered by the proportion of read number (RPKM) in the two groups (shown as the black line).


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6}

mset1.counts <- methResults$MSets1.counts.mean
mset2.counts <- methResults$MSets2.counts.mean
prop.counts <- mset1.counts / (mset1.counts + mset2.counts)

pvt.filter <- which(methResults$edgeR.p.value < reportPvalue)
filt.m1.c <- mset1.counts[pvt.filter]
filt.m2.c <- mset2.counts[pvt.filter]
filt.prop.c <- prop.counts[pvt.filter]

ms1n <- paste(unique(seqFiles[comparison[[an]]$mset1,"ctFlag"]), collapse="")
ms2n <- paste(unique(seqFiles[comparison[[an]]$mset2,"ctFlag"]), collapse="")

par(mar=c(5,4,4,5)+.1)
plot(1:length(filt.prop.c), filt.m1.c[order(filt.prop.c)], 
     ylim=c(0, max(c(filt.m1.c, filt.m2.c))), type="l", 
     col="red", xlab="Genomic window", ylab="Mean raw read depth")
points(1:length(filt.prop.c), filt.m2.c[order(filt.prop.c)], type="l", col="blue")
legend("topleft", fill=c("red", "blue", "black"), c(ms1n, ms2n, paste("% ", ms1n, sep="")))
par(new=TRUE)
plot(1:length(filt.prop.c), filt.prop.c[order(filt.prop.c)], type="l", 
     col="black", xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, col="black")
mtext(paste("% mean raw read depth in ", ms1n, sep=""), side=4, line=3, col="black")
```

**Figure 9b.** This figure shows mean raw read number of genomic windows with an edgeR p-value < `r format(reportPvalue, scientific = T)`. Genomic windows are ordered by the proportion of mean raw read number in the two groups (shown as the black line).


\newpage


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, dev='cairo_pdf'}

hist(methList[[pvc]]$maxLFC, breaks=20, xlab="Maximum DMR log fold change", ylab="Number of DMR", main="")

```

**Figure 10a.** This figure is a histogram showing the maximum log fold change in expression of DMR at an edgeR p-value < `r format(reportPvalue, scientific = T)`. Positive values indicate increased methylation in the `r paste(unique(seqFiles$ctFlag[comparison[[an]]$mset2]), collapse=",")` treatment group. Negative values indicate increased methylation in the `r paste(unique(seqFiles$ctFlag[comparison[[an]]$mset1]), collapse=",")` treatment group.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, dev='cairo_pdf'}

plot(1:nrow(methList[[pvc]]), sort(methList[[pvc]]$maxLFC), type="l", ylab="Maximum DMR log fold change", xlab="DMR")

```

**Figure 10b.** This figure is a histogram showing the log fold change of DMR at an edgeR p-value < `r format(reportPvalue, scientific = T)`.


\newpage

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, dev='cairo_pdf'}

raw.table <- methResults[,grep(x=colnames(methResults), pattern='bam.rpkm')]
colnames(raw.table) <- sn
sample.type <- seqFiles$ctFlag[match(sn, seqFiles$sampleName)]

pca.result <- prcomp(t(raw.table))
plot(pca.result$x[,1], pca.result$x[,2], col=as.numeric(as.factor(sample.type)),
     xlab = paste("PC1 - ", summary(pca.result)$importance[2,1]*100, "%", sep=""),
     ylab = paste("PC2 - ", summary(pca.result)$importance[2,2]*100, "%", sep=""),
     pch=19, cex=1.4, cex.axis=1.4, cex.lab=1.4)
legend("topright", unique(sample.type), fill=unique(as.numeric(as.factor(sample.type))))


```

**Figure 11.** This figure shows the samples plotted by the first two principal components. The underlying data is the RPKM read depth for all genomic windows.

\newpage


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6, dev='cairo_pdf'}

pvt.filter <- which(methResults$edgeR.p.value < reportPvalue)
raw.table <- methResults[pvt.filter,grep(x=colnames(methResults), pattern='bam.rpkm')]
colnames(raw.table) <- sn
sample.type <- seqFiles$ctFlag[match(sn, seqFiles$sampleName)]

pca.result <- prcomp(t(raw.table))
plot(pca.result$x[,1], pca.result$x[,2], col=as.numeric(as.factor(sample.type)),
     xlab = paste("PC1 - ", summary(pca.result)$importance[2,1]*100, "%", sep=""),
     ylab = paste("PC2 - ", summary(pca.result)$importance[2,2]*100, "%", sep=""),
     pch=19, cex=1.4, cex.axis=1.4, cex.lab=1.4)
legend("topright", unique(sample.type), fill=unique(as.numeric(as.factor(sample.type))))


```

**Figure 12.** This figure shows the samples plotted by the first two principal components. The underlying data is the RPKM read depth for all genomic windows with an edgeR p-value < `r format(reportPvalue, scientific = T)`.

