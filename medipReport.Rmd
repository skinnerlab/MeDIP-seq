---
output: pdf_document
---

<!-- Created 7/9/2015 by Daniel Beck-->
<!-- Last modified 5/2/2016 -->
<!-- This report generates the main MeDIP-seq analysis summary. It is usually called by the -->
<!-- generateReports.R script and requires the presence of a reportValues.Rdata file (this -->
<!-- file is generated by generateReports.R). -->

```{r, echo = FALSE, message = FALSE, warning = FALSE}

# Load relevant libraries, custom functions, and the configuration script. Note, the
# order is important, as dataNames.R holds information about the bsgenomePackageName.
source("dataNames.R")
source("customFunctions.R")
library(pander)
library(MEDIPS)
library(bsgenomePackageName, character.only = T, lib.loc = genomeDirectory)

#############################
## Load results parameters ##
#############################
## This step gets the report parameters from reportValues.Rdata and loads the appropriate
## result files for the MeDIP-seq analysis of interest.

# This file holds information on specific report variables. It is generated by generateReports.R
load("reportValues.Rdata")

# Select the desired comparison
an <- which(comparisonNames == analysisName)

# List position for these p-values
pvc <- which(pValues == reportPvalue)
MTCpvc <- which(MTCpValues == MTCreportPvalue)

# Load MeDIP-seq analysis results
load(paste(resultsDirectory, comparisonNames[an], "/methLists.RData", sep = ""))
load(paste(resultsDirectory, comparisonNames[an], "/methResults.RData", sep = ""))
load(paste(resultsDirectory, "qcLists.RData", sep=""))

sn <- c(seqFiles$sampleName[comparison[[an]]$mset1], seqFiles$sampleName[comparison[[an]]$mset2])

```

# MeDIP analysis summary for the `r projectName` project
Report generated `r format(Sys.Date(), format = "%B %d %Y")`
Comparison: `r comparisonNames[an]`

## Sample comparison
The samples `r paste(seqFiles$sampleName[comparison[[an]]$mset1], collapse = ", ")` were compared with the samples `r paste(seqFiles$sampleName[comparison[[an]]$mset2], collapse = ", ")`. The samples were analyzed in `r ifelse(comparison[[an]]$pairs[1], 'pairs', 'groups')`.

## Raw data cleaning and mapping
`r ifelse(cleanReads, "The raw data was cleaned and filtered to remove adapters and low-quality bases using Trimmomatic. The following table shows the differences in read numbers in the raw and cleaned files.", ifelse(useCleanReads, "The raw data was cleaned and filtered. The exact methods are not specified. The following table shows the differences in read numbers in the raw and cleaned files.", "No cleaning or filtering of the raw data is specified."))`

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

if (useCleanReads) {
  readCounts <- data.frame("sampleName" = sn, 
                           "rawReadPairs" = NA,
                           "cleanReadPairs" = NA,
                           "cleanReadSingles" = NA,
                           "pctCleanPairs" = NA,
                           "pctCleanTotal" = NA)
  for (i in 1:length(sn)) {
    subInd <- match(sn[i], seqFiles$sampleName)
    tempRawFileName <- seqFiles$p1FileName[subInd]
    tempCpFileName <- cleanFileNames[subInd, 1]
    tempS1FileName <- cleanFileNames[subInd, 3]
    tempS2FileName <- cleanFileNames[subInd, 4]
  
    cRaw <- paste("zcat ", dataDirectory, tempRawFileName, ' | grep "^@" | wc -l', sep="")
    cPair <- paste("zcat ", dataDirectory, tempCpFileName, ' | grep "^@" | wc -l', sep="")
    cS1 <- paste("zcat ", dataDirectory, tempS1FileName, ' | grep "^@" | wc -l', sep="")
    cS2 <- paste("zcat ", dataDirectory, tempS2FileName, ' | grep "^@" | wc -l', sep="")
    
    numRaw <- as.numeric(system(cRaw, intern=T))
    numPair <- as.numeric(system(cPair, intern=T))
    numS1 <- as.numeric(system(cS1, intern=T))
    numS2 <- as.numeric(system(cS2, intern=T))
  
    totalS <- numS1 + numS2
    readCounts[i, 2:6] <- c(numRaw, numPair, totalS, numPair / numRaw, (numPair + totalS) / numRaw)
  }
  # Double underscore is a special character, remove them.
  readCounts$sampleName <- gsub(readCounts$sampleName, pattern="__", replacement="_")
  row.names(readCounts) <- readCounts[,1]
  readCounts <- readCounts[, -1]
  pandoc.table(readCounts, split.tables = 100, style = "simple", 
               caption = "This table shows the number and percent of reads before and 
                         after read filtering and trimming.")
}

```


The following table shows the association between the samples and the original data files.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
fnTable <- as.data.frame(seqFiles[match(sn, seqFiles$sampleName), ])
fnTable$sampleName <- gsub(fnTable$sampleName, pattern="__", replacement="_")
row.names(fnTable) <- fnTable$sampleName
fnTable <- fnTable[, -1]
colnames(fnTable) <- c("first end filename", "second end filename", "sample type")
pandoc.table(fnTable, split.tables = 100, style = "simple", 
             caption = "This table shows the association between the samples 
                       and the raw data files.")
```

A quality report for each raw data file was generated using FastQC and is available in the folder `r dataDirectory`. The raw data consists of 50bp paired end reads. The reads were mapped to the reference genome using Bowtie2.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
if (mapReads){
  tmp <- mapExtract(cleaned = useCleanReads)
  colnames(tmp) <- gsub(colnames(tmp), pattern="__", replacement="_")
  pandoc.table(tmp, split.tables = 100, style = "simple", 
               caption = 'This table shows the number of reads present for each sample 
                         and the overall alignment rate calculated by bowtie2.')
}

```

The *`r species`* reference genome was provided by `r provider` and was downloaded from `r genomeSourceFiles`. The mapped reads were converted to the sorted BAM file format using Samtools.

************

## Differential coverage analysis
The differential coverage analysis was performed using the MEDIPS R package. The analysis used a windows size of `r ws`bp. The `r diff.method` method was used to calculate p-values. The `r p.adj` multiple testing adjustment was also calculated. Annotation information was downloaded from `r ifelse(annotationType == "biomart", 'the Ensembl database using the biomaRt R package', annotationSource)`.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
ptable <- data.frame("unique"=uniq, "extend"=extend, "shift"=shift, "window.size"=ws, "p.adj"=p.adj, "diff.method"=diff.method, "min.row.sum"=minRowSum)
pandoc.table(ptable, split.tables = 100, style = "simple", 
             caption = 'This table shows various parameters used for the MEDIPS analysis')
```

### DMR definition
DMRs were defined using a `r diff.method` p-value threshold of `r reportPvalue` or a `r p.adj` adjusted p-value threshold of `r MTCreportPvalue`. The DMR edges were extended to include neighboring windows with a p-value less than `r dmrBoundPvalue`. Genomic windows are considered neighboring if they are within `r adjDist`bp of the DMR boundary. In other words, DMR edges are extended until there is no genomic window within `r adjDist`bp with a p-value less than `r dmrBoundPvalue`. 

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

pandoc.table(as.data.frame(dmrNumberTable), split.tables = 100, style = "simple", 
             caption = "This table shows the number of DMRs found using different p-value cutoff 
                     thresholds. The allWindow column shows all DMRs. The twoWindow column 
                     shows the number of DMRs containing at least two significant windows.")

pandoc.table(as.data.frame(MTCdmrNumberTable), split.tables = 100, style = "simple", 
             caption = "This table shows the number of DMRs found using different multiple 
                       testing corrected p-value cutoff thresholds. The allWindow column shows 
                       all DMRs. The twoWindow column shows the number of DMRs containing at least 
                       two significant windows.")

```

************

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
nWin <- table(methList[[pvc]]$numSigWin)
nWinTable <- as.data.frame(matrix(ncol = length(nWin), nrow = 2, c(names(nWin), nWin), byrow = T))
row.names(nWinTable) <- c("Number of significant windows", "Number of DMR")
colnames(nWinTable) <- rep(" ", ncol(nWinTable))
pandoc.table(nWinTable, split.tables = 100, style = "simple", 
             caption = paste("This table shows the number of DMR with each specific number of 
                             significant windows at a p-value threshold of ", 
                             reportPvalue, sep = ""))
             
```

### Overall p-value distribution
The overall p-value distribution shows a summary of the p-values for each genomic window. Odd patterns in the histogram below may indicate problems with the data or the analysis.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
layout(matrix(c(1, 2), nrow = 2), heights = c(1, 1.5))
par(mar = c(2.1, 4.1, 1.1, 2.1))
a <- hist(methResults$edgeR.p.value, breaks = 100, main = "", xlab = "")
par(mar = c(5.1, 4.1, 1.1, 2.1))
ylim <- sort(a$counts, decreasing = TRUE)[2]
if (is.na(ylim)) ylim <- 1
hist(methResults$edgeR.p.value, breaks = 100, 
     ylim = c(0, ylim), xlab = "edgeR p-value", main = "")
```

**Figure 1.** This figure shows the histogram of the edgeR p-values for all genomic windows. The top plot shows the entire histogram while the bottom plot has a truncated y-axis to better show low-frequency p-values.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
layout(matrix(c(1, 2), nrow = 2), heights = c(1, 1.5))
par(mar = c(2.1, 4.1, 1.1, 2.1))
a <- hist(methResults$edgeR.adj.p.value, breaks = 100, main = "", xlab = "")
par(mar = c(5.1, 4.1, 1.1, 2.1))
ylim <- sort(a$counts, decreasing = T)[2]
if (is.na(ylim)) ylim <- 1
hist(methResults$edgeR.adj.p.value, breaks = 100, ylim = c(0, ylim), 
     xlab = paste(p.adj, " adjusted p-value", sep = ""), main = "")
```

**Figure 2.** This figure shows the histogram of the `r paste(p.adj, " adjusted p-values", sep="")` for all genomic windows. The top plot shows the entire histogram while the bottom plot has a truncated y-axis to better show low-frequency p-values.

******

### Chromosome plot

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}
# Find clusters
dmrList <- methList[[pvc]]

clusterObject <- slidingWindowCluster(formatForCluster(dmrList),
                                      windowLength = 2000000, incrementLength = 50000)
colnames(clusterObject) <- c("chr", "start", "stop", "minP")
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths,
                ymar = 5, clusters = clusterObject)

```

**Figure 3.** This figure shows the DMR locations on the individual chromosomes or contigs. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}
# find clusters
dmrList <- methList2p[[pvc]]

clusterObject <- slidingWindowCluster(formatForCluster(dmrList),
                                      windowLength = 2000000, incrementLength = 50000)
colnames(clusterObject) <- c("chr", "start", "stop", "minP")
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths,
                ymar = 5, clusters = clusterObject)

```

**Figure 4.** This figure shows the DMR locations on the individual chromosomes or contigs. Only DMRs containing at least two significant windows at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.


******

### CpG density histogram

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
par(mar = c(5, 5, 4, 2) + 0.1)
plotCpGdensity(methList[[pvc]], main = "", xlab = "Number of CpG sites per 100bp", 
               ylab = "Number of differential DNA \n methylation regions")
```

**Figure 5.** This figure is a histogram of the number of DMRs at different CpG densities. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
par(mar=c(5, 5, 4, 2) + 0.1)
plotCpGdensity(methList2p[[pvc]], main = "", xlab = "Number of CpG sites per 100bp",
               ylab = "Number of differential DNA \n methylation regions")
```

**Figure 6.** This figure is a histogram of the number of DMRs at different CpG densities. Only DMRs containing at least two significant windows at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.


### DMR characteristics

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
plotDMRlength(methList[[pvc]])
```

**Figure 7.** This figure is a histogram of the DMR lengths. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
plotDMRlength(methList2p[[pvc]])
```

**Figure 8.** This figure is a histogram of the DMR lengths. Two window DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
if(!is.null(methList[[pvc]]$cpgNum)){
  plot(methList[[pvc]]$cpgNum, methList[[pvc]]$length, xlab = "Number of CpGs", 
       ylab = "DMR length (bp)")
}
```

**Figure 9.** This figure shows the DMR length vs number of CpGs. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
if(!is.null(methList2p[[pvc]]$cpgNum)){
  plot(methList2p[[pvc]]$cpgNum, methList2p[[pvc]]$length, xlab = "Number of CpGs", 
       ylab = "DMR length (bp)")
}
```

**Figure 10.** This figure shows the DMR length vs number of CpGs. Two window DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 7}
a <- NULL
if (cVar) {
  s1cols <- match(paste(sbamFileName[comparison[[an]]$mset1], ".rpkm", sep = ""), 
                  colnames(methResults))
  s2cols <- match(paste(sbamFileName[comparison[[an]]$mset2], ".rpkm", sep = ""), 
                  colnames(methResults))
  sdH <- apply(methResults[, s1cols], 1, sd)
  sdN <- apply(methResults[, s2cols], 1, sd)
  cvH <- sdH / methResults[, "MSets1.rpkm.mean"]
  cvN <- sdN / methResults[, "MSets2.rpkm.mean"]
  
  sigWin <- methResults[which(methResults$edgeR.p.value < reportPvalue), ]
  SWsdH <- apply(sigWin[, s1cols], 1, sd)
  SWsdN <- apply(sigWin[, s2cols], 1, sd)
  SWcvH <- SWsdH / sigWin[, "MSets1.rpkm.mean"]
  SWcvN <- SWsdN / sigWin[, "MSets2.rpkm.mean"]
 
  colorVector <- colorRampPalette(c("red", "black", "blue"))(100)
  evenDist <- ((sigWin$edgeR.p.value-min(sigWin$edgeR.p.value))/(max(sigWin$edgeR.p.value)-min(sigWin$edgeR.p.value)))*100
  evenDist <- sapply(floor(evenDist)+1, function(i) min(i, 100))
  SWcol <- colorVector[evenDist]
 
  dH <- density(cvH, na.rm = T)
  dN <- density(cvN, na.rm = T)
  SWdH <- density(SWcvH, na.rm = T)
  SWdN <- density(SWcvN, na.rm = T)
  plot(dH$x, dH$y, type = "l", col = "red", ylim = c(0, max(c(dH$y, dN$y, SWdH$y, SWdN$y))), 
       xlab = "CV for RPKM corrected coverage values", ylab = "Frequency across genomic windows")
  points(dN$x, dN$y, type = "l", col = "red", lty = 5)
  points(SWdH$x, SWdH$y, type="l", col = "blue")
  points(SWdN$x, SWdN$y, type="l", col = "blue", lty = 5)
  legend(fill = c("red", "blue"), c("all", paste("p<", reportPvalue, sep="")), x = "top")
  
  
  s1n <- names(table(seqFiles$ctFlag[comparison[[an]]$mset1]))
  s2n <- names(table(seqFiles$ctFlag[comparison[[an]]$mset2]))
  a <- paste("Figure 11. This figure shows the smoothed distribution of CV for RPKM 
              corrected coverage values across genomic windows. All genomic windows for 
              both ", s1n, " and ", s2n, " populations are colored red. The subset of genomic 
              windows with a p-value less than ", reportPvalue ," for both control and 
              treatment populations are colored blue. ", s1n, " populations are shown with 
              solid lines and ", s2n, " populations with dashed lines.", sep = "")
  
}
```

`r a`


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 7}
a <- NULL
if (cVar) {
  layout(matrix(ncol = 2, nrow = 2, c(3, 1, 0, 2)), widths = c(7, 1), heights = c(1, 7))
  par(mar = c(5, 4, 0, 0) + 0.1)
  plot(SWcvH, SWcvN, xlab = paste(s1n, " CV", sep = ""), ylab = paste(s2n, " CV", sep = ""), 
       col = SWcol, xlim = c(0, 1.73), ylim = c(0, 1.73))
  SWhH <- hist(SWcvH, plot = F)
  SWhN <- hist(SWcvN, plot = F)
  par(mar = c(5.1, 0, 0, 0.1))
  bhH <- barplot(SWhN$density, horiz = T, axes = F)
  par(mar = c(0, 4.1, 0.1, 0))
  barplot(SWhH$density, axes = F)
  
  a <- paste("Figure 12. This figure shows the CV for RPKM corrected coverage values for ", 
             s1n, " samples vs. ", s2n, " samples. Points are colored by p-value, with blue 
             having the highest p-value, red having the lowest, and black being intermediate. 
             These colors are relative and scaled evenly between the highest and lowest p-values.
             Only genomic windows with a p-value less than ", reportPvalue, " are shown here. 
             Histograms on the x and y axis show the CV distribution of genomic windows in the ", 
             s1n, " and ",s2n, " samples respectively.", sep = "")
}

```

`r a`



************

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

a <- as.data.frame(corMatrix)
colnames(a) <- seqFiles$sampleName[match(colnames(corMatrix), sbamFileName)]
row.names(a) <- seqFiles$sampleName[match(row.names(corMatrix), sbamFileName)]
a <- a[which(match(row.names(a), sn, nomatch=0)>0), which(match(colnames(a), sn, nomatch=0)>0)]

row.names(a) <- gsub(row.names(a), pattern="__", replacement="_")
colnames(a) <- gsub(colnames(a), pattern="__", replacement="_")

pandoc.table(a, split.tables=100, style="simple", caption="This table shows the pairwise Pearson correlation coefficient between sample coverage profiles.")

```


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}

par(mfcol=c(3,2))
subCoverList <- coverList[which(match(seqFiles$sampleName, sn, nomatch=0)>0)]
for (i in 1:length(subCoverList)) {
  histMax(coverList[[i]]$cov.res, max=15,
          xlab=paste("Coverage\n", format(subCoverList[[i]]$numberReadsWO / subCoverList[[i]]$numberReads*100, digits=3), "% of reads do not cover a CpG", sep=""),
          ylab = "Number of CpGs",
          main = sn[i])
}

```

**Figure 13.** This figure shows the distribution of CpG coverage across the genome for each sample.


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6}

par(mfcol=c(1,1))
mset1.counts <- methResults$MSets1.rpkm.mean
mset2.counts <- methResults$MSets2.rpkm.mean
prop.counts <- mset1.counts / (mset1.counts + mset2.counts)

pvt.filter <- which(methResults$edgeR.p.value < reportPvalue)
filt.m1.c <- mset1.counts[pvt.filter]
filt.m2.c <- mset2.counts[pvt.filter]
filt.prop.c <- prop.counts[pvt.filter]

ms1n <- paste(unique(seqFiles[comparison[[an]]$mset1,"ctFlag"]), collapse="")
ms2n <- paste(unique(seqFiles[comparison[[an]]$mset2,"ctFlag"]), collapse="")

par(mar=c(5,4,4,5)+.1)
plot(1:length(filt.prop.c), filt.m1.c[order(filt.prop.c)], 
     ylim=c(0, max(c(filt.m1.c, filt.m2.c))), type="l", 
     col="red", xlab="Genomic window", ylab="Mean RPKM")
points(1:length(filt.prop.c), filt.m2.c[order(filt.prop.c)], type="l", col="blue")
legend("topleft", fill=c("red", "blue", "black"), c(ms1n, ms2n, paste("% ", ms1n, sep="")))
par(new=TRUE)
plot(1:length(filt.prop.c), filt.prop.c[order(filt.prop.c)], type="l", 
     col="black", xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, col="black")
mtext(paste("% RPKM read depth in ", ms1n, sep=""), side=4, line=3, col="black")
```

**Figure 14.** This figure shows mean read number (RPKM) of genomic windows with an edgeR p-value < `r reportPvalue`. Genomic windows are ordered by the proportion of read number (RPKM) in the two groups (shown as the black line).

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6}

mset1.counts <- methResults$MSets1.counts.mean
mset2.counts <- methResults$MSets2.counts.mean
prop.counts <- mset1.counts / (mset1.counts + mset2.counts)

pvt.filter <- which(methResults$edgeR.p.value < reportPvalue)
filt.m1.c <- mset1.counts[pvt.filter]
filt.m2.c <- mset2.counts[pvt.filter]
filt.prop.c <- prop.counts[pvt.filter]

ms1n <- paste(unique(seqFiles[comparison[[an]]$mset1,"ctFlag"]), collapse="")
ms2n <- paste(unique(seqFiles[comparison[[an]]$mset2,"ctFlag"]), collapse="")

par(mar=c(5,4,4,5)+.1)
plot(1:length(filt.prop.c), filt.m1.c[order(filt.prop.c)], 
     ylim=c(0, max(c(filt.m1.c, filt.m2.c))), type="l", 
     col="red", xlab="Genomic window", ylab="Mean raw read depth")
points(1:length(filt.prop.c), filt.m2.c[order(filt.prop.c)], type="l", col="blue")
legend("topleft", fill=c("red", "blue", "black"), c(ms1n, ms2n, paste("% ", ms1n, sep="")))
par(new=TRUE)
plot(1:length(filt.prop.c), filt.prop.c[order(filt.prop.c)], type="l", 
     col="black", xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, col="black")
mtext(paste("% mean raw read depth in ", ms1n, sep=""), side=4, line=3, col="black")
```

**Figure 15.** This figure shows mean raw read number of genomic windows with an edgeR p-value < `r reportPvalue`. Genomic windows are ordered by the proportion of mean raw read number in the two groups (shown as the black line).



```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6}

plot(1:length(filt.prop.c), filt.prop.c[order(filt.prop.c)], type="l", 
     col="black", xlab="Genomic window", ylab="% mean raw read depth")

```

**Figure 16.** This figure shows the proportion of mean raw read number in the two groups for genomic windows with an edgeR p-value < `r reportPvalue`.



```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 6}

pvt.filter <- which(methResults$edgeR.p.value < reportPvalue)
raw.table <- methResults[pvt.filter,grep(x=colnames(methResults), pattern='bam.rpkm')]
colnames(raw.table) <- sn
sample.type <- seqFiles$ctFlag[match(sn, seqFiles$sampleName)]

pca.result <- prcomp(t(raw.table))
plot(pca.result$x[,1], pca.result$x[,2], col=as.numeric(as.factor(sample.type)),
     xlab = paste("PC1 - ", summary(pca.result)$importance[2,1]*100, "%", sep=""), 
     ylab = paste("PC2 - ", summary(pca.result)$importance[2,2]*100, "%", sep=""))
legend("topleft", c(ms1n, ms2n), fill=c("black", "red"))

```

**Figure 17.** This figure shows the samples plotted by the first two principal components. The underlying data is the RPKM read depth for all genomic windows with an edgeR p-value < `r reportPvalue`.

