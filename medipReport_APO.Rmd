---
output: pdf_document
---

<!-- Created by Daniel Beck on 5/31/2016 -->
<!-- Last modified 7/12/2016 -->

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# Load relevant libraries, custom functions, and the configuration script. Note, the
# order is important, as dataNames.R holds information about the bsgenomePackageName.
source("dataNames.R")
source("customFunctions.R")
library(pander)
library(bsgenomePackageName, character.only = T, lib.loc = genomeDirectory)
library(VennDiagram)
library(MEDIPS)

# This file holds information on specific report variables. It is generated by generateReports.R
load("reportValues.Rdata")

# Select the desired comparison
an <- which(apo.names == analysisName)

# List position for these p-values
pvc <- which(pValues == reportPvalue)
MTCpvc <- which(MTCpValues == MTCreportPvalue)

## Load relevant analyses
pair.analysis.env <- list()  # list of environments that will hold paired analyses
for (i in 1:length(apo.pair.analysis.names[[an]])) {
  pair.analysis.env[[i]] <- local({load(paste(resultsDirectory, 
                                              apo.pair.analysis.names[[an]][i], 
                                              "/methLists.RData", sep = "")); environment()})
}


dmrTable.list <- lapply(pair.analysis.env, function(i) i$methList[[pvc]])    
dmrTable2p.list <- lapply(pair.analysis.env, function(i) i$methList2p[[pvc]])


load(paste(resultsDirectory, analysisName, "/methListsAPO.RData", sep = ""))
load(paste(resultsDirectory, "qcLists.RData", sep=""))

sampleDef <- do.call(rbind, comparison[match(apo.pair.analysis.names[[an]], comparisonNames)])


## Modify stop (this is normally done in medipProcessing
for (i in 1:length(methListAPO)) {
  methListAPO[[i]] <- modifyStop(dmrList = methListAPO[[i]], 
                                 refGenome = eval(parse(text = referenceName)), 
                                 maxDMR = 10000)
  methList2pAPO[[i]] <- modifyStop(dmrList = methList2pAPO[[i]], 
                                   refGenome = eval(parse(text = referenceName)), 
                                   maxDMR = 10000)
}

## Calculate CpG density if not already available
for (i in 1:length(methListAPO)) {
  if (!match("cpgNum", colnames(methListAPO[[i]]), nomatch=0)) {
    methListAPO[[i]] <- calcCpGdensity(dmrList=methListAPO[[i]], maxDMR=10000)
  }
  if (!match("cpgNum", colnames(methList2pAPO[[i]]), nomatch=0)) {
    methList2pAPO[[i]] <- calcCpGdensity(dmrList=methList2pAPO[[i]], maxDMR=10000)
  }
}

for (i in 1:length(MTCmethListAPO)) {
  if (!match("cpgNum", colnames(MTCmethListAPO[[i]]), nomatch=0)) {
    MTCmethListAPO[[i]] <- calcCpGdensity(dmrList = MTCmethListAPO[[i]], maxDMR = 10000)
  }
  if (!match("cpgNum", colnames(MTCmethList2pAPO[[i]]), nomatch=0)) {
    MTCmethList2pAPO[[i]] <- calcCpGdensity(dmrList = MTCmethList2pAPO[[i]], maxDMR = 10000)
  }
}

```

# MeDIP analysis summary for the `r projectName` project
Report generated `r format(Sys.Date(), format = "%B %d %Y")`
Arbitrary pair overlap (APO) `r paste(apo.pair.analysis.names[[an]], collapse = ", ")`

## Sample comparison
The samples `r paste(seqFiles$sampleName[sampleDef$mset1], collapse = ", ")` were compared with the samples `r paste(seqFiles$sampleName[sampleDef$mset2], collapse = ", ")`. The samples were analyzed in pairs.

## Raw data cleaning and mapping
`r ifelse(cleanReads, "The raw data was cleaned and filtered to remove adapters and low-quality bases using Trimmomatic. The following table shows the differences in read numbers in the raw and cleaned files.", ifelse(useCleanReads, "The raw data was cleaned and filtered. The exact methods are not specified. The following table shows the differences in read numbers in the raw and cleaned files.", "No cleaning or filtering of the raw data is specified."))`


## Raw data cleaning and mapping
`r ifelse(cleanReads, "The raw data was cleaned and filtered to remove adapters and low-quality bases using Trimmomatic. The following table shows the differences in read numbers in the raw and cleaned files.", ifelse(useCleanReads, "The raw data was cleaned and filtered. The exact methods are not specified. The following table shows the differences in read numbers in the raw and cleaned files.", "No cleaning or filtering of the raw data is specified."))`

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
sn <- c(seqFiles$sampleName[sampleDef$mset1], seqFiles$sampleName[sampleDef$mset2])

if (useCleanReads) {
  readCounts <- data.frame("sampleName" = sn, 
                           "rawReadPairs" = NA,
                           "cleanReadPairs" = NA,
                           "cleanReadSingles" = NA,
                           "pctCleanPairs" = NA,
                           "pctCleanTotal" = NA)
  for (i in 1:length(sn)) {
    subInd <- match(sn[i], seqFiles$sampleName)
    tempRawFileName <- seqFiles$p1FileName[subInd]
    tempCpFileName <- cleanFileNames[subInd, 1]
    tempS1FileName <- cleanFileNames[subInd, 3]
    tempS2FileName <- cleanFileNames[subInd, 4]
  
    cRaw <- paste("zcat ", dataDirectory, tempRawFileName, ' | grep "^@" | wc -l', sep="")
    cPair <- paste("zcat ", dataDirectory, tempCpFileName, ' | grep "^@" | wc -l', sep="")
    cS1 <- paste("zcat ", dataDirectory, tempS1FileName, ' | grep "^@" | wc -l', sep="")
    cS2 <- paste("zcat ", dataDirectory, tempS2FileName, ' | grep "^@" | wc -l', sep="")
    
    numRaw <- as.numeric(system(cRaw, intern=T))
    numPair <- as.numeric(system(cPair, intern=T))
    numS1 <- as.numeric(system(cS1, intern=T))
    numS2 <- as.numeric(system(cS2, intern=T))
  
    totalS <- numS1 + numS2
    readCounts[i, 2:6] <- c(numRaw, numPair, totalS, numPair / numRaw, (numPair + totalS) / numRaw)
  }
  row.names(readCounts) <- readCounts[,1]
  readCounts <- readCounts[, -1]
  pandoc.table(readCounts, split.tables = 110, style = "rmarkdown", 
               caption = "This table shows the number and percent of reads before and 
                         after read filtering and trimming.")
}

```


The following table shows the association between the samples and the original data files.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
fnTable <- as.data.frame(seqFiles[match(sn, seqFiles$sampleName), ])
row.names(fnTable) <- fnTable$sampleName
fnTable <- fnTable[, -1]
colnames(fnTable) <- c("first end filename", "second end filename", "sample type")
pandoc.table(fnTable, split.tables = 110, style = "rmarkdown", 
             caption = "This table shows the association between the samples 
                       and the raw data files.")
```

A quality report for each raw data file was generated using FastQC and is available in the folder `r dataDirectory`. The raw data consists of 50bp paired end reads. The reads were mapped to the reference genome using Bowtie2.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
if (mapReads){
  #anA <- an
  #meList <- list()
  #for (i in 1:length(anA)) {
  #  an <- anA[i]
  #  meList[[i]] <- mapExtract(cleaned = useCleanReads)
  #}
  #an <- anA
  #mpTable <- do.call(cbind, meList)
  #mpTable <- cbind(mpTable[, -(1:length(an)*2)], mpTable[, 1:length(an)*2])
  #pandoc.table(mpTable, split.tables = Inf, style = "rmarkdown", 
  #             caption = 'This table shows the number of reads present for each sample 
  #                       and the overall alignment rate calculated by bowtie2.')

  pandoc.table(mapExtract(cleaned = useCleanReads), split.tables = Inf, style = "rmarkdown", 
               caption = 'This table shows the number of reads present for each sample 
                         and the overall alignment rate calculated by bowtie2.')
}

```

The *`r species`* reference genome was provided by `r provider` and was downloaded from `r genomeSourceFiles`. The mapped reads were converted to the sorted BAM file format using Samtools.

************

## Differential coverage analysis
The differential coverage analysis was performed using the MEDIPS R package. The analysis used a windows size of `r ws`bp. The `r diff.method` method was used to calculate p-values. The `r p.adj` multiple testing adjustment was also calculated. Annotation information was downloaded from `r ifelse(annotationType == "biomart", 'the Ensembl database using the biomaRt R package', annotationSource)`.

The MEDIPS analysis was run seperatly for each pair of samples. Because there is no replication within the control or treatment groups for each pair, the underlying model parameters are not fit to the data. This complicates the interpretation of the resulting DMR. Any resulting p-values or other statistics should be treated only as a ranking.

### DMR definition
Pairwise DMRs were defined for each analysis using a `r diff.method` p-value threshold of `r reportPvalue`. The DMR edges were extended to include neighboring windows with a p-value less than `r dmrBoundPvalue`. Genomic windows are considered neighboring if they are within `r adjDist`bp of the DMR boundary. In other words, DMR edges are extended until there is no genomic window within `r adjDist`bp with a p-value less than `r dmrBoundPvalue`. 

The subset of pairwise DMR that overlapped in every analysis were then taken as the final set of DMR. The significance of these DMR is not clear, both due to uncertain model parameters for each pairwise analysis and the added filtering step that includes only overlapping DMR.

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

pandoc.table(as.data.frame(dmrNumberTableAPO), split.tables = 110, style = "rmarkdown", 
             caption = "This table shows the number of APO DMRs found using different 
                     p-value cutoff thresholds. The allWindow column shows all DMRs. 
                     The twoWindow column shows the number of DMRs containing at least 
                     two significant windows.")

pandoc.table(as.data.frame(MTCdmrNumberTableAPO), split.tables = 110, style = "rmarkdown", 
             caption = "This table shows the number of APO DMRs found using different multiple 
                       testing corrected p-value cutoff thresholds. The allWindow column shows 
                       all DMRs. The twoWindow column shows the number of DMRs containing at least
                       two significant windows.")

```

***************

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
nWin <- table(methListAPO[[pvc]]$numSigWin)
nWinTable <- as.data.frame(matrix(ncol = length(nWin), nrow = 2, c(names(nWin), nWin), byrow = T))
row.names(nWinTable) <- c("Number of significant windows", "Number of DMR")
colnames(nWinTable) <- rep(" ", ncol(nWinTable))
pandoc.table(nWinTable, split.tables = 110, style = "rmarkdown", 
             caption = paste("This table shows the number of DMR with each specific number of 
                             significant windows at a p-value threshold of ", 
                             reportPvalue, sep = ""))
             
```


### Chromosome plot

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}
# Find clusters
dmrList <- methListAPO[[pvc]]

clusterObject <- slidingWindowCluster(formatForCluster(dmrList), 
                                      windowLength = 2000000, incrementLength = 50000)
colnames(clusterObject) <- c("chr", "start", "stop", "minP")
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths, 
                ymar = 5, clusters = clusterObject)

```

**Figure 1.** This figure shows the DMR locations on the individual chromosomes or contigs. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}
# find clusters
dmrList <- methList2pAPO[[pvc]]

clusterObject <- slidingWindowCluster(formatForCluster(dmrList), 
                                      windowLength = 2000000, incrementLength = 50000)
colnames(clusterObject) <- c("chr", "start", "stop", "minP")
chrLengths <- seqlengths(eval(parse(text = referenceName)))
plotChromosomes(siteTable = dmrList, chrLengths = chrLengths, 
                ymar = 5, clusters = clusterObject)

```

**Figure 2.** This figure shows the DMR locations on the individual chromosomes or contigs. Only DMRs containing at least two significant windows at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.



### CpG density histogram

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
par(mar = c(5, 5, 4, 2) + 0.1)
plotCpGdensity(methListAPO[[pvc]], main = "", xlab = "Number of CpG sites per 100bp", 
               ylab = "Number of differential DNA \n methylation regions")
```

**Figure 3.** This figure is a histogram of the number of DMRs at different CpG densities. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
par(mar=c(5, 5, 4, 2) + 0.1)
plotCpGdensity(methList2pAPO[[pvc]], main = "", xlab = "Number of CpG sites per 100bp",
               ylab = "Number of differential DNA \n methylation regions")
```

**Figure 4.** This figure is a histogram of the number of DMRs at different CpG densities. Only DMRs containing at least two significant windows at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.


### DMR characteristics

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
plotDMRlength(methListAPO[[pvc]])
```

**Figure 5.** This figure is a histogram of the DMR lengths. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
plotDMRlength(methList2pAPO[[pvc]])
```

**Figure 6.** This figure is a histogram of the DMR lengths. Two window DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
if(!is.null(methListAPO[[pvc]]$cpgNum)){
  plot(methListAPO[[pvc]]$cpgNum, methListAPO[[pvc]]$length, xlab = "Number of CpGs", 
       ylab = "DMR length (bp)")
}
```

**Figure 7.** This figure shows the DMR length vs number of CpGs. All DMRs at a p-value threshold of `r format(reportPvalue,scientific=T)` are shown here.

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}
if(!is.null(methList2pAPO[[pvc]]$cpgNum)){
  plot(methList2pAPO[[pvc]]$cpgNum, methList2pAPO[[pvc]]$length, xlab = "Number of CpGs", 
       ylab = "DMR length (bp)")
}
```

**Figure 8.** This figure shows the DMR length vs number of CpGs. Two window DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.



************
## Arbitrary pair overlaps by analysis


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}

vennDMR(dmr.list = dmrTable.list, group.names = apo.pair.analysis.names)


```
**Figure 9.** This figure shows the number of overlapping DMR between each pairwise analysis. All DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 4.5}

vennDMR(dmr.list = dmrTable2p.list, group.names = apo.pair.analysis.names)

```
**Figure 10.** This figure shows the number of overlapping DMR between each pairwise analysis. Multiple window DMRs at a p-value threshold of `r format(reportPvalue, scientific = T)` are shown here.

************

## Other figures

```{r, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}

a <- as.data.frame(corMatrix)
colnames(a) <- seqFiles$sampleName[match(colnames(corMatrix), sbamFileName)]
row.names(a) <- seqFiles$sampleName[match(row.names(corMatrix), sbamFileName)]
a <- a[which(match(row.names(a), sn, nomatch=0)>0), which(match(colnames(a), sn, nomatch=0)>0)]
pandoc.table(a, split.tables=110, style="rmarkdown", caption="This table shows the pairwise Pearson correlation coefficient between sample coverage profiles.")

```


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 8}

par(mfcol=c(3,2))
subCoverList <- coverList[which(match(seqFiles$sampleName, sn, nomatch=0)>0)]
for (i in 1:length(subCoverList)) {
  histMax(coverList[[i]]$cov.res, max=15,
          xlab=paste("Coverage\n", format(subCoverList[[i]]$numberReadsWO / subCoverList[[i]]$numberReads*100, digits=3), "% of reads do not cover a CpG", sep=""),
          ylab = "Number of CpGs",
          main = sn[i])
}

```

**Figure 11.** This figure shows the distribution of CpG coverage across the genome for each sample.








